---
title: 'Flutter 톺아보기 - 플러터는 어떻게 동작할까? (그리고 내가 느낀 플러터의 한계점...)'
date: '2025-06-08'
updatedDate: ''
image: ''
excerpt: ''
tag: 'Flutter'
---

### **Intro**

최근에 플러터를 쓸 일이 많이 생겼다.

개발을 하다보면 버그를 엄청 만나게 되는데 대체 이놈은 어떻게 생겨먹었길래 이런 메시지를 띄우는지 궁금해졌다.

어떤 문제가 생겼을 때 내부의 구조를 알면 디버깅 시간을 단축할 수 있기 때문에, 앞으로 시간을 내어 공식 문서와 함께 플러터를 알아가는 시간을 가져보도록 하겠음.

원본 글 : https://docs.flutter.dev/resources/architectural-overview

### **계층적 아키텍쳐 (Layter Architecture)**

플러터의 아키텍쳐는 크게 세 가지 핵심 레이어로 나뉜다.

1. 프레임워크 : 다트 언어로 작성되는 영역으로, 개발자가 작업을 진행하는 레이어.
2. 엔진 : 플러터의 심장부, C++ 로 작성됨.
3. 임베더 : 각 플랫폼 (android, ios) 와 플러터를 연결하는 다리 역할을 한다.

![](https://i.imgur.com/9E1IYwr.png)

**_Engine Layer_**
![](https://i.imgur.com/wvPbwAU.png)

엔진은 플러터의 핵심이다. 대부분 C++로 작성이 되어있고, 플러터 앱 지원에 필요한 기본적인 요소들을 담고있다. Framework 레이어가 '무엇을' 그릴지 결정한다면, Engine 이 실제로 그것을 화면에 그려내는 역할을 하는 것.

엔진이 하는 일 중 하나는 `Rasterizing` 이다. 이건 뭐냐면 화면을 새로 그려야 할 때마다, 개발자가 위젯으로 구성한 각 화면을 실제 화면의 픽셀로 변환하는 것을 의미한다. 화면에 그리기 위해 필요한 low level 의 핵심 기능을 수행한다.

- 그래픽 처리: 화면을 그리는 실제 도구, 최근에는 Impeller 라는 새로운 렌더링 엔진 도입으로, ios 와 android 에서 더 부드러운 애니메이션을 제공하고, 그 이외의 플랫폼에서는 Skia 를 사용함. (Rendering, Composition, Frame Scheduling, Frame Pipelining...)
- 텍스트 레이아웃 : 글자를 화면에 어떻게 배치하고 렌더링 할지 계산.
- 파일 및 네트워크 I/O : (Asset Resolution) 루트의 pubsec.yaml 에 등록한 이미지나 폰트 같은 애셋을 실제로 읽어오는 역할...
- 플러그인 아키텍쳐 : 카메라, GPS 와 같은 네이티브 기능을 사용할 수 있도록 연결하는 통로를 제공. (Platform channels)
- Dart 런타임 및 컴파일 툴체인 : Dart 코드를 실행하고, 릴리즈 시에는 네이티브 기계어로 컴파일을 하는 환경. (Dart Isolate Setup, Dart Runtime Mgmt)

이런 플러터 엔진이 Dart 로 작성된 Framework 레이어와 소통하기 위해 사용하는 것이 `dart:ui` 라이브러리이다. Flutter Framework 에서 작업을 할 때 모든 위젯과 애니메이션은 기본적으로 이 `dart:ui` 를 통해 엔진에게 그려줘! 애니메이션 시작해줘! 같은 명령을 내리는 것.

예를 들어서, Container 라는 위젯을 사용하게 된다면 내부에서는 Widgets -> Rendering -> dart:ui -> Engine .. 과 같은 순서대로 명령을 전달하여 처리한다. 이렇게 추상화가 아름답게 되어있기 때문에 복잡한 내부를 알지 못해도 쉽게 UI를 구성할 수 있다.

**_Framework layer_**
![](https://i.imgur.com/uKycStn.png)

이 프레임워크 레이어가 UI를 그리고 엔진과 소통을 하는 역할을 담당한다. 이 안에서도 여러 레이어로 겹겹이 쌓여있는데, 아래로 내려갈수록 추상화가 된 상위 계층이라고 보면 된다.

1. 최하위 계층 : Foudation & Services (Animation, Painting, Gestures...)
   - 프레임워크의 가장 기반이 되는 계층으로, 복잡한 엔진의 기능을 직접 건드리지 않고 사용할 수 있게 가장 기본적인 기능들을 Dart로 추상화 해놓은 계층. Animation, Painting, Gesture 같은 서비스와 기본적인 기반 클래스가 Foundation 을 토대로 추상화가 되어있다.
2. 렌더링 레이어
   - 화면의 레이아웃을 계산하고 그리는 것을 책임지는 계층. 위젯 트리를 통해 실제로 화면에 그려져야 할 렌더 트리를 생성한다. 렌더 트리내부의 각 객체가 좌표값과 구체적은 크기정보를 계산하여 가지고 있고, `setState`() 가 호출되어 화면이 변경되면, 이 렌더 트리가 변경사항을 감지해 화면 레이아웃을 효율적으로 업데이트 한다.
3. 위젯 레이어
   - 플러터의 핵심 철학이 담긴 계층... 조합을 통해서 레고 블록을 조합하듯이 위젯들을 조합해 화면 UI를 그려나간다.
4. 최상위 계층 : Material & Cupertino
   - 구글의 Material 디자인과 애플의 Cupertino 디자인을 미리 구현해놓은 부품 세트가 존재한다. 개발자가 디자인 시스템의 세세한 부분을 신경쓰지 않아도 네이티브스러운 UI를 만들 수 있게 도와준다.

공식 문서에 따르면 플러터의 프레임워크는 비교적 작은데, 개발자들이 사용할만한 고수준의 기능들을 패키지로서 구현해 필요에 따라 가져올 수 있도록 넓은 생태계를 유지한다고 함. 근데 이 핵심 기능들에는 camera 나 webview 같은 플랫폼 플러그인 뿐 아니라, http, animations 와 같은 플랫폼에 구애받지 않는 핵심 Dart, 플러터 라이브러리 기반 기능도 포함됨.

그러니까 코어는 작은데 패키지로 이루어진 생태계가 크기 때문에 확장성과 유연성을 그리고 더 빠른 개발 속도를 낼 수 있다고 주장하고 있음.

내가 하고있던 오해는 플러터의 모든 패키지가 다 플러터 공식 패키지라고 생각했는데, npm 과 마찬가지로 커뮤니티 패키지 혹은 내가 직접 만든 패키지도 존재할 수 있는것이었음.

**_Embedder layer_**
![](https://i.imgur.com/g9z4jM7.png)

플러터 애플리케이션은 최종적으로 각 OS 의 표준 패키지 (android의 경우 APK/ABB, ios 의 경우 IPA..)로 빌드된다. 실행 관점에서 이 앱은 실행 가능한 네이티브 앱이고, 이게 Dart 인지 아니면 네이티브 언어로 작성되었는지는 구분하지 않는다. (그럴 필요도 없다.)

Dart 코드는 빌드 시에 각 플랫폼에 맞는 네이티브 기계어로 컴파일이 되고, 이 결과물이 UI 렌더링과 앱 생명주기를 관리하는 플러터 엔진 - 거대한 네이티브 라이브러리와 함께 패키징이 된다. 따라서 결과물은 네이티브 앱이 맞지만, 이 내부 구조와 동작 방식은 네이티브 앱 대비 근본적인 차이점이 있다.

_*(이 설명을 보다보니, OS 관점에서 아 얘는 네이티브 앱 아니네.. 이렇게 판단되고 실행되는 다른 케이스가 있을까? 가 궁금해졌다. 그래서 잠깐 찾아보니... 일단 OS에서 실행이 되려면 실행 가능판 네이티브 패키지여야 하고.. 여기서 내부 구조가 어떻게 동작하는지에 따라 차이점이 발생하는 것 같다.*_

_*리액트 네이티브와 아이오닉/코르도바 (잘 모르겠는걸 보니 점유율이 상당히 낮은듯)과 같은 타 프레임워크는 플러터처럼 모든 코드를 다 네이티브로 컴파일 하는 것이 아닌, 자바스크립트 해석기 혹은 웹뷰 같은 것을 사용하기 때문에 플러터가 이들 대비 성능상의 이점이 있는 것을 보임.)*_

어쨌든 다시 돌아와서... 플러터에서 앱 패키징을 담당하는 부분은 `Embedder` 라는 친구인데, 이는 앱에 대한 진입점(Entrypoint)를 제공한다. 그리고 OS 와 협력을 필요로 하는 부분 - 화면 렌더링, 터치, 입력과 같은 OS 신호를 플러터 엔진이 알아들을 수 있게 번역해서 전달하는 역할을 한다. 또한 메시지 이벤트 루프를 관리한다. 이벤트 루프 - 비동기적으로 발생할 수 있는 이벤트들 예를들면 사용자의 터치, 네트워크 응답과 같은 것들을 관리한다.

설명에 따르면, 임베더는 각 플랫폼에 친숙한 언어로 작성이 된다고 함. 예를들어 안드로이드는 Java 와 C++, ios 는 swift/Object-C/C++, 윈도우 및 리눅스는 C++... 이 임베더를 통해서 기존 네이티브 앱에 모듈로서 통합을 하는 것 (Add-to-App) 이 가능해진다.

**여기서 잠깐 Add-to-App (모듈로서의 통합) 이 뭘까..**

위 설명에서 살펴봤듯 임베더는 플러터 엔진을 포장해서 네이티브와 연결하는 징검다리 역할을 한다. 그래서 이 임베더를 통해서 플러터를 하나의 모듈로 만들어 기존에 존재하는 네이티브와 연결할 수가 있다. android 는 `Activity`, ios 는 `ViewController` 라는 개념이 있어서, 네이티브에서 이것들을 호출해 플러터 모듈을 불러올 수 있다고 함.

네이티브를 잘 몰라서 정확히 어떻게 동작하는지는 모르겠는데, 레거시에 플러터를 점진적으로 도입하거나, 아무래도 플러터가 복잡한 UI도 빠르게 만들 수 있다는 장점이 있기에 생산성 측면에서 도입을 하는 등.. 임베더를 통해 네이티브와 통합하는 전략도 가능하다고 함.

임베더 라는 것은 ios, android ... 과 같은 다양한 플랫폼에 대응하지만, 제 3자가 직접 만들 수도 있다고 함. 그 예시로 삼성전자의 타이젠 OS 나 다른 제 3의 OS를 위한 임베더 등... [Flutter for Tizen](https://developer.samsung.com/smarttv/develop/native/flutter.html)

### **플러터의 한계점**

갑자기 잘 파고들다가 결론을 갑자기 한계점. 이러는게 웃기긴 하지만..

이쯤 살펴보니 내가 궁금했던 기본적인 부분에 대해서는 어느정도 해소가 된 것 같다.
그래서 (토이 플젝이나 웹뷰로 단기간 찍먹이긴 하지만) 지금까지 플러터를 사용하고 느낀 개인적 소감을 정리해보고 싶다.

일단 플러터는 만능이 아닌 것 같다.

만능의 의미는, 플러터 하나만 알고있으면 모든 플랫폼에 대응하는 애플리케이션을 만들 수 있어! << 이거는 반은 맞고 반은 틀렸다고 생각. 처음에는 진짜 그런줄 알았는데, 결국 각 플랫폼에 대응되는 네이티브에 대한 지식을 갖추고 있어야만 하는 순간이 온다.

다만 뭔가 빠르게 처음부터 mvp 를 만들어서 가능성을 확인해본다던지, 아니면 기존에 네이티브 지식을 가지고 있는 앱 개발자가 조금 더 생산적이고 빠르게 개발을 한다면 그런 의미에서는 만능이 될 수도 있다고 봄.

근데 본인은 네이티브에 대한 지식이 0에 수렴하는 웹 FE 였기 때문에 처음부터 앱을 빌딩하면서 또 웹뷰로 작업을 하면서 그렇게 쉽지만은 않다는 생각을 많이 하게 되었음.

언제 이걸 느꼈냐면, 조금 급하게 앱 업데이트를 담당하게 되었을때임. 그렇게 복잡한 기능을 가지고 있지 않음에도 그동안의 플러터 업데이트, 각종 패키지 업데이트가 마구마구 일어나서 이에 대응을 해주어야했고, 각 플랫폼에 맞게 빌드를 하는 과정에서 정말 수많은 에러를 맞닥뜨렸다. (최악..식은땀 줄줄..😣)

처음에는 플러터 자체의 문제일거라고 생각했는데, 에러를 좀 파고들다 보니 플러터를 각 플랫폼에 맞게 패키징을 하는 과정에서 gradle 버전 문제가 발생한다던지, ios의 경우에는 cocoapods 에서 의존성 관리가 꼬여있다던지 이런 각 네이티브에 대한 문제가 대부분이었다. (gradle 은 플러터 버전, jdk 버전, 그에 호환되는 gradle 버전등을 공식문서로 찾아보고 업데이트해서 해결했고, ios 의 경우에는 오래된 패키지 다 업데이트 해버리고 쓰지도 않고 되지도 않는건 그냥 삭제해버리면서 몽땅 최신화를 해버렸다..)

그리고 조금 더 딥한 네이티브의 기능을 이용한다던지, 패키지로 제공되지 않는 부분을 직접 구현한다던지 할 때는 아예 네이티브 관련 코드를 수정해야만 하는 경우도 많은 것 같다.

현재 우리 사이드 프로젝트가 플러터 기반의 웹뷰로 구현이 되어있는데, 만약 이런 사실들에 대해 미리 알았다면 각 플랫폼을 네이티브로 구현해서 대응을 했을 것 같다. **_만약 당신이 앱을 만들고 싶은 웹개발자고 웹뷰를 쓸건데 플러터를 아예 모른다면 차라리 코틀린이나 스위프트를 알아보는것도....... ㅋㅋ_**

내가 하도 고생만 해서 플러터에 대해 안좋은 점만 왕왕 나열한 것 같지만, 정말 추상화가 아름답게 되어있고 제공하는 기능도 많은 훌륭한 프레임 워크임에는 틀림없다고 봄.

아무튼 나는 플러터로 앱을 구성하는 것에 대해서는 대충(ㅋㅋ) 알고있으니까 앞으론 코틀린이나 스위프트에 대해서 조금씩 공부를 해보며 얘네는 어떨지 알아가보도록 하겠음.
